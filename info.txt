INFIX OPERATORS:
	||    - logical or
	&&    - logical and
	==    - logical equal test
	!=    - logical not eaual test
	<     - logical lesser test
	>     - logical greater test
	<=    - logical lesser or equal test
	>=    - logical greater or equal test
	+     - add
	+%    - add with carry
	-     - subtract
	-%    - subtract with borrow
	*     - multiply
	*%    - wide multiply
	/     - divide
	/%    - divide with remainder
	%     - modulo	
	%%    - concatenate
	|     - bitwise or
	~|    - bitwise nor
	&     - bitwise and
	~&    - bitwise nand
	><    - bitwise xor
	<<    - bitwise left shift
	>>    - bitwise right shift (logic for unsigned, aritmetic for signed)


RIGHT TO LEFT BINARY OPERATORS:
	=       - assign
	type->  - cast to other type
	type/>  - reinterpret to other type


PREFIX OPERATORS:
	'       - dereference
	*       - get address of
	+       - plus
	-       - minus
	!       - logical not
	~       - bitwise not
	*       - pointer
	^       - viewing pointer
	[]      - range
	[^]     - viewing range

POSTFIX OPERATORS;
	[index, ...]   - access through indexes
	(args, ...)    - call procedure or operator ()
	[begin..end]   - get an array slice
	[begin..]      - get an array slice with default end
	[..end]        - get an array slice with default begin
	[]             - get an array slice with default begin and end
	{args, ...}    - initialized struct literal

	.member	       - access to a member
	.[index]       - access to a member by index (index can be a number or a string containing the name of field)
	.(args, ...)   - access to procedure pointer with selected parameters



PROCEDURE SPECIFIERS:
	..             - inline
	{args, ...}    - commute // not sure if it's worth implementing

INPUT ARGUMENTS SPECIFIERS:
	:     - restrict
	&     - reference (like value inside the procedure, but like non mutable pointer or value outside it)
	::    - value, must avalible at compile time
	::=   - special overload, add overload for specific value of some type
	!     - restrict

OUTPUT ARGUMENTS SPECIFIERS:
	'    - dereference output (dereferences return value, used for array access operator)

Input arguments can be default initialized.
The default parameters will be initialized outside of procedure call.
Default initialized input parameter works as procedure overload.

SPECIAL TYPES:
	void                                    - has 0 size, you cannot do anything with it
	byte(Expr)                              - has 1 size, and control its alignment by "Expr" (default alignment is 1)
	[]                                      - range, consists of pointer and size
	[^]                                     - viewing range, consists of viewing pointer and size
	[Expr]                                  - array with fixed size
	[[Expr]]                                - variable size array with fixed capacity
	[Expr]->Type                            - structure of arrays with fixed size
	[[Expr]]->Type                          - variable size structure of arrays with fixed capacity
	*                                       - pointer
	^                                       - viewing pointer

HIDDEN TYPES:
	generic enum                     - has an enum type which nothing else can have because its a keyword
	dereferenced pointer (reference) - has type of the value ponted by the pointer
  

CONSTRUCTOR, DESTRUCTORS:
	Constructors, and destructors does not exist.
	There are a type traits needs_init(Type) and needs_deinit(Type) which can tell if the type needs
	to be initialized or deinitialized.
	Intialization can be done by using procedures or by default of coutum initializetion.
	Deinitializetion should be implemented by the procedure: deinit :: proc(object : *Type){}
